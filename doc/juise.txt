#
# $Id$
#
# Copyright 2011, Juniper Networks, Inc.
# All rights reserved.
# This SOFTWARE is licensed under the LICENSE provided in the
# ../Copyright file. By downloading, installing, copying, or otherwise
# using the SOFTWARE, you agree to be bound by the terms of that
# LICENSE.
#

JUISE is a environment for writing, debugging, and executing SLAX
scripts.  This environment is tailored to the needs of JUNOS-oriented
scripts, including op scripts and commit scripts.

In addition, there are tools to integrate scripts with web servers.

* JUISE

The JUISE project (the JUNOS User Interface Scripting Environment)
allows scripts to be written, debugged, and executed outside the
normal JUNOS environment.  Users can develop scripts in their desktop
environment, performing the code/test/debug cycle in a more natural
way.  Tools for developers are available, including a debugger, a
profiler, a call-flow tracing mechanism, and trace files.  
The JUNOS-specific extension functions are available for scripts,
allowing access to JUNOS XML data using the normal jcs:invoke and
jcs:execute functions.  Commit scripts can be tested against a JUNOS
device's configuration and the results of those script tested on that
device.

JUISE scripts are typically written in SLAX, an alternative syntax for
XSLT.  For information about SLAX, refer to libslax.googlecode.com.
Additional reference material is available under the "JUNOS
Automation" section of http://junos.juniper.net.

The JUISE software can be used to execute scripts independent of a
JUNOS box, allowing the use of SLAX scripts in the off-box world.
Scripts can communicate with zero or more devices, allowing a
centralized manipulation of multiple devices.

JUISE includes a rudimentary NETCONF server, allowing JUNOS devices to
invoke RPCs to unix devices.  JUNOS devices can perform NETCONF or
JUNOScript RPCs to a JUISE box, and invoke scripts or programs on that
device. 

JUISE includes "mod_juise", a plug-in module for lighttpd, allowing
the execution of scripts via HTTP.  At this point, the portion of
JUISE is completely experimental.

** Getting JUISE

JUISE is available as an open-source project via google code using the
following URL:

    http://juise.googlecode.com

Refer to the ./README file for building instructions.

** The "juise" Command

The "juise" command is the central program of the JUISE project.  It
is used to test, format, convert, debug, and execute scripts.

The "juise" command has four distinct usage patterns, which are
discussed in this section.

- op script mode
- commit script mode
- server mode
- cgi mode

*** Syntax

Usage: juise [[user]@target] [options] [script] [param value]*

The juise command is normally invoked with the name of the script to
be run, a set of options are used to tailor the execution of the
script, and a set of name/value parameter pairs that are passed as
parameters to the script, as they are for the JUNOS "op" command.

A token containing an '@' will be taken as the default target of a
jcs:open() call, allowing either "user@device" or "@device".

*** Command Line Options

= --agent OR -A
Enable forwarding of ssh-agent credentials, allowing remote ssh
sessions to connect to the local ssh-agent process for authentication
information.  See "man ssh-agent(1)" for details.

= --debug OR -d Start the libslax debugger, allowing the user to
interactively debug script execution.  Refer to the debugger
documentation in the libslax distribution for more information
(libslax.googlecode.com).

= --directory <dir> OR -D <dir>
Use the given directory as the location for server scripts.  This
directory can also be set using the JUISE_DIR environment variable.

= --include <dir> OR -I <dir>
Add the given directory to the search path for files that are
referenced via the SLAX "include" or "import" statements.

= --indent OR -g
Make indented output as if the script contained:

    output-method {
        indent "yes";
    }

(The "-g" is for "good-looking output").

= --input <file> OR -i <file>
Use given file for input.

= --junoscript OR -J
Default to using the older JUNOScript XML API instead of the NETCONF
API for jcs:open() connections.

= --lib <dir> OR -L <dir>
Add the given directory to the list of directories searched for
dynamic extension libraries.  Refer to libslax for more information.

= --no-randomize
Avoid initializing the random number generator so script execution can
be predictable (e.g. during debugging).

= --param <name> <value> OR -a <name> <value>
An alternative method of giving parameters to a script.

= --protocol <name> OR -P <name>
Use the given protocol as the default protocol for jcs:open()
connections. 

= --run-server OR -R
Run juise in server mode, where it accepts incoming RPCs and executes
scripts given by the RPC name.  See ^server^ section for details.

= --script <name> OR -S <name>
An alternative method of giving the script name.

= --target <name> OR -T <name>
An alternative method of giving the default target name.

= --trace <file> OR -t <file>
Save trace data to the given file.

= --user <name> OR -u <name>
An alternative method of giving the user name for API connections.

= --verbose OR -v
Enable debugging output.  Any calls to slaxLog() will be displayed.

= --version OR -V
Display any version information, including the versions of libslax,
libxslt, and libxml2.  After displaying this information,
juise will exit.

= --wait <seconds>
After starting and parsing arguments, juise will wait for the
specified number of seconds, allowing the user to attach to the
process with "gdb" for additional debugging.

*** Running JUNOS Scripts

The information passed to scripts depends on the mode in which the
script operates.  This section describes the modes of juise that
relate to JUNOS.

**** Setting Up the Import Path

JUNOS scripts typically import junos.xsl using the following
statement:

    import "../import/junos.xsl";




**** Op Scripts

Op scripts are passed an empty document as input.  Any command line
parameters are passed as SLAX parameters.  Output can be generated by
"message" statements and "jcs:output" calls, as well as by the XML
document which the script generates.

**** Commit Scripts

Commit scripts are not yet functional.

**** Event Scripts

Event scripts are not yet functional.

*** Running Native Scripts

juise can also be used to develop scripts that are not intended to run
under JUNOS.  The off-box environment gives a number of distinct
advantages for scripts that operate like "op" scripts.  These scripts
join the simplicity and flexibility of SLAX to the unix environment.

**** "#!/usr/bin/slax"

The SLAX parser supports the "#!" mechanism which is a normal part of
the unix environment.  This allows scripts beginning
with the line "#!/usr/bin/slax" to be executed directly from the
command line.

    #!/usr/bin/slax
    match / { message "this works"; }

If this script file is given the appropriate "executable" permission
bit (such as "chmod a+x works"), then the command "works" will work.

    % works
    this works
    %

Additional options can be added to the "#!" line:

    #!/usr/bin/slax -g --param check yes

** mod_juise

The JUISE project includes a plug-in module for the "lighttpd" (aka
"lightey") web server.  This plug-in allows scripts to be run directly
from lighttpd will allowing SSH credentials established using
"ssh-agent" to be inherited by the SLAX script.  SSH connections,
including those from the jcs:open() call, can be opened without
prompting for a passphrase.

To add mod_juise to your lighttpd server, add the following line to
your lighttpd.conf file:

    juise.assign = ( ".slax" => "juise.cgi" )

*** juise.cgi

When a file ending in ".slax" is requested, lighttpd will pass the
request to mod_juise which will invoke juise using the "juise.cgi"
driver.  This driver will fetch the CGI-defined variables and make
them available to the script as both global parameters and as elements
inside the "$cgi" global parameter.  Scripts are free to use either
method to retrieve these values.  The following table list the CGI
parameter name and the $cgi element name.

|-------------------+-------------------|
| Parameter Name    | Element Name      |
|-------------------+-------------------|
| CONTENT_LENGTH    | content-length    |
| DOCUMENT_ROOT     | document-root     |
| GATEWAY_INTERFACE | gateway-interface |
| HTTPS             | https             |
| LD_LIBRARY_PATH   | ld-library-path   |
| LD_PRELOAD        | ld-preload        |
| PATH_INFO         | path-info         |
| QUERY_STRING      | query-string      |
| REDIRECT_STATUS   | redirect-status   |
| REMOTE_ADDR       | remote-addr       |
| REMOTE_PORT       | remote-port       |
| REMOTE_USER       | remote-user       |
| REQUEST_METHOD    | request-method    |
| REQUEST_URI       | request-uri       |
| SCRIPT_FILENAME   | script-filename   |
| SCRIPT_NAME       | script-name       |
| SERVER_ADDR       | server-addr       |
| SERVER_NAME       | server-name       |
| SERVER_PORT       | server-port       |
| SERVER_PROTOCOL   | server-protocol   |
| SERVER_SOFTWARE   | server-software   |
| SYSTEMROOT        | systemroot        |
|-------------------+-------------------|

The following lines are equivalent:

    expr "User is " _ $REMOTE_USER;
    expr "User is " _ $cgi/remote-user;

In addition $cgi has an element named "parameters" which has the
fields of $QUERY_STRING broken into individual elements.  These are
also available as global parameters.  The following lines are
equivalent: 

    expr "'from' parameter is " _ $cgi/parameters/from;
    expr "'from' parameter is " _ $from;

The full set of parameters can be accessed using this parameters
element:

    for-each ($cgi/parameters) {
        expr "Parameter '" _ name() _ "' is '" _ . _ "'";
    }

*** The <cgi> Element

When SLAX scripts are invoked via mod_juise, the script can choose to
emit a top level element named <cgi>.  This element is used to supply
directions to the HTTP server.

*** Attributes

Any non-namespace attributes given on the <cgi> element is converted
into a header field in the HTTP reply message.  The attribute name is
the header field and the attribute value is the header value.

    <cgi Content-Type="text/html" X-Address=$REMOTE_ADDR>
        ...
    </cgi>

The above element would be turned into:

    Content-Type: text/html
    X-Address: 10.1.2.3

Additional attributes and elements may be defined under the <cgi>
element.  For future proofing, script should avoid attributes and
elements whose names being with "junos", "cgi", or "juise".

** NETCONF Server @server@

juise can perform as a NETCONF server using the "-R" or "--run-server"
option.

XXX needs more

** Extension Libraries

The JUISE project includes several dynamic extension, which are
installed into the normal extension directory where they are available
for any SLAX script.  This section details the extension functions and
element of those libraries.

*** jcs

The "jcs" namespace is used for JUNOS-specific extension function, but
many of the functions are no longer JUNOS specific.  "jcs" was
originally for "JUNOS Commit Scripts", but these functions can be used
for other sorts of scripting as well.

In addition, many of the extension functions in the "slax" namespace
were originally in the "jcs" namespace, and are now available in both
namespaces.   The following table lists these dual-homed functions.

|---------------|
| Function Name |
|---------------|
| break-lines   |
| break_lines   |
| dampen        |
| empty         |
| first-of      |
| get-command   |
| get-input     |
| get-secret    |
| getsecret     |
| input         |
| is-empty      |
| output        |
| progress      |
| printf        |
| regex         |
| sleep         |
| split         |
| sprintf       |
| sysctl        |
| syslog        |
| trace         |
|---------------|


**** jcs:open

The jcs:open() function creates a connection to either the local
machine (for on-box JUNOS scripts) or a remote device using the
NETCONF or JUNOScript API.  This connection can be passed to
jcs:execute() to invoke RPCs and to jcs:close() to close the
connection.

Three protocols can be used for network access:
- netconf: IETF standard (RFC6241) over the standard netconf port with
the netconf subsystem
- junoscript: the original JUNOScript API accessed over the standard
ssh port using the JUNOS CLI
- junos-netconf: the NETCONF protocol accessed over the standard
ssh port using the JUNOS CLI

"junoscript" and "junos-netconf" have the advantage of not requiring
additional configuration, where "netconf" has the advantage of being
the full standard mechanism.

The behavior of jcs:open varies with the number of arguments given:

- If no arguments are passed and the script is running under JUNOS, a
connection to the local device is created.  RPCs are processed within
the device and no network login is needed.

- If no arguments are passed and the script is not running under
JUNOS, the arguments to the juise program are using to build a
connection.  The "--target", "--user", and "--protocol" options, along
with the "[user]@target" argument (if provided), identify the target
of the connection.

- If one argument is provided, the argument is the name of the device
to connect with.  The name may be in either "target" or "user@target"
format.

- If two arguments are provided, the first argument is the name of the
device to connect with, and the second argument is a node-set with the
following members.

|--------------------+---------------------------------------|
| Element Name       | Value                                 |
|--------------------+---------------------------------------|
| connection-timeout | Seconds before connect fails          |
| method             | netconf, junos-netconf, or junoscript |
| passphrase         | SSH passphrase                        |
| password           | User password                         |
| port               | Transport port number                 |
| timeout            | Connection timeout                    |
| username           | User login name                       |
|--------------------+---------------------------------------|

- If three arguments are provided, the first argument is the name of
the device to connect with, the second is the username, and the third
is the password.

    SYNTAX::
        node-set jcs:open();
        node-set jcs:open(hostname);
        node-set jcs:open(hostname, info);
        node-set jcs:open(hostname, username, password);

    EXAMPLE::
        var $info = {
            <port> 5000;
            <timeout> 600;
        }
        var $conn = jcs:open($target, $info);

**** jcs:execute

The jcs:execute() function invokes RPCs using a connection returned by
jcs:open().  RPCs are invoked and their results returned using a
persistent connection, allowing stateful RPCs, such as locking the
configuration database.

The first argument is the connection, as returned by jcs:open().  If the
second argument is a string, it is the name of an RPC operation.
Otherwise the second argument is a node-set containing the operation
to be invoked.

    SYNTAX::
        node-set jcs:execute(conn, method);
        node-set jcs:execute(conn, rpc);

    EXAMPLE::
        var $rpc = <get-interface-information> {
            <interface-name> "fe-0/0/0";
            <statistics>;
        }
        var $res = jcs:execute($conn, $rpc);
        var $sw = jcs:execute($conn, "get-software-information");

**** jcs:invoke

The jcs:invoke() function invokes RPCs but does not use or require a
persistent connection.  RPCs are stateless, since any connection
needed is temporary, so operations like locking the configuration
database should be avoided since the lock will be immediately
released.

If the argument to jcs:invoke is a string, it is the name of an RPC
operation.  Otherwise the argument is a node-set containing the
operation to be invoked.

    SYNTAX::
        node-set jcs:invoke(method);
        node-set jcs:invoke(rpc);

    EXAMPLE::
        var $rpc = <get-interface-information> {
            <interface-name> "fe-0/0/0";
            <statistics>;
        }
        var $res = jcs:invoke($rpc);
        var $sw = jcs:invoke("get-software-information");

**** jcs:close

The jcs:close() function closes a connection opened by jcs:open(),
releasing any resources on both the local and remote side.

    SYNTAX::
        void jcs:close(conn);

{{document:
    name juise-manual;
    private "The JUISE Project";
    ipr none;
    category exp;
    abbreviation JUISE-MANUAL;
    title "The JUISE Project: JUNOS User Interface Scripting Environment";
    contributor "author:Phil Shafer:Juniper Networks:phil@juniper.net";
}}
